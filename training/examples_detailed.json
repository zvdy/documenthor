[
  {
    "repository_name": "flask-user-service",
    "repository_structure": {
      "app.py": "from flask import Flask, request, jsonify\nfrom flask_sqlalchemy import SQLAlchemy\nfrom werkzeug.security import generate_password_hash, check_password_hash\nimport os\n\napp = Flask(__name__)\napp.config['SQLALCHEMY_DATABASE_URI'] = os.getenv('DATABASE_URL', 'sqlite:///users.db')\napp.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False\ndb = SQLAlchemy(app)\n\nclass User(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    username = db.Column(db.String(80), unique=True, nullable=False)\n    email = db.Column(db.String(120), unique=True, nullable=False)\n    password_hash = db.Column(db.String(120), nullable=False)\n    \n    def set_password(self, password):\n        self.password_hash = generate_password_hash(password)\n    \n    def check_password(self, password):\n        return check_password_hash(self.password_hash, password)\n\n@app.route('/health', methods=['GET'])\ndef health_check():\n    return jsonify({'status': 'healthy', 'service': 'user-service'})\n\n@app.route('/users', methods=['POST'])\ndef create_user():\n    data = request.get_json()\n    user = User(\n        username=data['username'],\n        email=data['email']\n    )\n    user.set_password(data['password'])\n    db.session.add(user)\n    db.session.commit()\n    return jsonify({'id': user.id, 'username': user.username}), 201\n\n@app.route('/users/<int:user_id>', methods=['GET'])\ndef get_user(user_id):\n    user = User.query.get_or_404(user_id)\n    return jsonify({'id': user.id, 'username': user.username, 'email': user.email})\n\n@app.route('/users', methods=['GET'])\ndef list_users():\n    users = User.query.all()\n    return jsonify([{'id': u.id, 'username': u.username, 'email': u.email} for u in users])\n\nif __name__ == '__main__':\n    with app.app_context():\n        db.create_all()\n    app.run(debug=True, host='0.0.0.0', port=5000)",
      "requirements.txt": "Flask==2.3.3\nFlask-SQLAlchemy==3.0.5\nWerkzeug==2.3.7\npytest==7.4.2\npytest-flask==1.2.0\nrequests==2.31.0",
      "config.py": "import os\n\nclass Config:\n    SECRET_KEY = os.environ.get('SECRET_KEY') or 'dev-secret-key'\n    SQLALCHEMY_DATABASE_URI = os.environ.get('DATABASE_URL') or 'sqlite:///users.db'\n    SQLALCHEMY_TRACK_MODIFICATIONS = False\n\nclass DevelopmentConfig(Config):\n    DEBUG = True\n\nclass ProductionConfig(Config):\n    DEBUG = False\n\nconfig = {\n    'development': DevelopmentConfig,\n    'production': ProductionConfig,\n    'default': DevelopmentConfig\n}",
      "tests/test_app.py": "import pytest\nimport json\nfrom app import app, db, User\n\n@pytest.fixture\ndef client():\n    app.config['TESTING'] = True\n    app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///:memory:'\n    with app.test_client() as client:\n        with app.app_context():\n            db.create_all()\n        yield client\n\ndef test_health_check(client):\n    response = client.get('/health')\n    assert response.status_code == 200\n    data = json.loads(response.data)\n    assert data['status'] == 'healthy'\n\ndef test_create_user(client):\n    response = client.post('/users', \n                        json={'username': 'testuser', 'email': 'test@example.com', 'password': 'password123'})\n    assert response.status_code == 201\n    data = json.loads(response.data)\n    assert data['username'] == 'testuser'\n\ndef test_get_user(client):\n    # First create a user\n    client.post('/users', json={'username': 'testuser', 'email': 'test@example.com', 'password': 'password123'})\n    response = client.get('/users/1')\n    assert response.status_code == 200\n    data = json.loads(response.data)\n    assert data['username'] == 'testuser'",
      "Dockerfile": "FROM python:3.9-slim\n\nWORKDIR /app\n\nCOPY requirements.txt .\nRUN pip install --no-cache-dir -r requirements.txt\n\nCOPY . .\n\nEXPOSE 5000\n\nCMD [\"python\", \"app.py\"]",
      "docker-compose.yml": "version: '3.8'\nservices:\n  web:\n    build: .\n    ports:\n      - \"5000:5000\"\n    environment:\n      - DATABASE_URL=postgresql://user:password@db:5432/userdb\n    depends_on:\n      - db\n  db:\n    image: postgres:13\n    environment:\n      - POSTGRES_DB=userdb\n      - POSTGRES_USER=user\n      - POSTGRES_PASSWORD=password\n    volumes:\n      - postgres_data:/var/lib/postgresql/data\n\nvolumes:\n  postgres_data:"
    },
    "expected_readme": "# Flask User Service\n\nA RESTful microservice for user management built with Flask and SQLAlchemy.\n\n## Features\n\n- User registration and management\n- Password hashing with Werkzeug\n- SQLAlchemy ORM with PostgreSQL/SQLite support\n- Docker containerization\n- Comprehensive test suite\n- Health check endpoint\n- Production-ready configuration\n\n## Quick Start\n\n### Local Development\n\n1. Clone the repository:\n```bash\ngit clone <repository-url>\ncd flask-user-service\n```\n\n2. Create a virtual environment:\n```bash\npython -m venv venv\nsource venv/bin/activate  # On Windows: venv\\Scripts\\activate\n```\n\n3. Install dependencies:\n```bash\npip install -r requirements.txt\n```\n\n4. Run the application:\n```bash\npython app.py\n```\n\nThe service will be available at `http://localhost:5000`\n\n### Docker\n\n1. Build and run with Docker Compose:\n```bash\ndocker-compose up --build\n```\n\nThis will start the Flask app with a PostgreSQL database.\n\n## API Endpoints\n\n### Health Check\n```\nGET /health\n```\nReturns service status.\n\n### User Management\n\n#### Create User\n```\nPOST /users\nContent-Type: application/json\n\n{\n  \"username\": \"johndoe\",\n  \"email\": \"john@example.com\",\n  \"password\": \"securepassword\"\n}\n```\n\n#### Get User\n```\nGET /users/{user_id}\n```\n\n#### List All Users\n```\nGET /users\n```\n\n## Testing\n\nRun the test suite:\n```bash\npytest tests/\n```\n\nRun with coverage:\n```bash\npytest tests/ --cov=app\n```\n\n## Configuration\n\nThe application supports different environments through configuration classes:\n\n- Development: SQLite database, debug mode enabled\n- Production: PostgreSQL database, debug mode disabled\n\n### Environment Variables\n\n- `DATABASE_URL` - Database connection string\n- `SECRET_KEY` - Flask secret key for sessions\n- `FLASK_ENV` - Environment (development/production)\n\n## Database Schema\n\n### User Model\n- `id` (Integer, Primary Key)\n- `username` (String, Unique)\n- `email` (String, Unique)\n- `password_hash` (String)\n\n## Security\n\n- Passwords are hashed using Werkzeug's security functions\n- Input validation on all endpoints\n- SQL injection protection through SQLAlchemy ORM\n\n## Deployment\n\nThe service is containerized and can be deployed to any Docker-compatible platform:\n\n- Kubernetes\n- Docker Swarm\n- Cloud platforms (AWS ECS, Google Cloud Run, etc.)\n\n## License\n\nMIT License"
  },
  {
    "repository_name": "express-auth-service",
    "repository_structure": {
      "package.json": "{\n  \"name\": \"express-auth-service\",\n  \"version\": \"1.0.0\",\n  \"description\": \"JWT-based authentication microservice built with Express.js\",\n  \"main\": \"src/index.js\",\n  \"scripts\": {\n    \"start\": \"node src/index.js\",\n    \"dev\": \"nodemon src/index.js\",\n    \"test\": \"jest\",\n    \"test:watch\": \"jest --watch\",\n    \"test:coverage\": \"jest --coverage\",\n    \"lint\": \"eslint src/\",\n    \"lint:fix\": \"eslint src/ --fix\"\n  },\n  \"keywords\": [\"express\", \"jwt\", \"authentication\", \"microservice\", \"api\"],\n  \"author\": \"Development Team\",\n  \"license\": \"MIT\",\n  \"dependencies\": {\n    \"express\": \"^4.18.2\",\n    \"jsonwebtoken\": \"^9.0.2\",\n    \"bcryptjs\": \"^2.4.3\",\n    \"mongoose\": \"^7.5.0\",\n    \"cors\": \"^2.8.5\",\n    \"helmet\": \"^7.0.0\",\n    \"express-rate-limit\": \"^6.10.0\",\n    \"joi\": \"^17.9.2\",\n    \"dotenv\": \"^16.3.1\"\n  },\n  \"devDependencies\": {\n    \"nodemon\": \"^3.0.1\",\n    \"jest\": \"^29.6.2\",\n    \"supertest\": \"^6.3.3\",\n    \"eslint\": \"^8.47.0\",\n    \"mongodb-memory-server\": \"^8.15.1\"\n  },\n  \"engines\": {\n    \"node\": \">=16.0.0\"\n  }\n}",
      "src/index.js": "const express = require('express');\nconst mongoose = require('mongoose');\nconst cors = require('cors');\nconst helmet = require('helmet');\nconst rateLimit = require('express-rate-limit');\nrequire('dotenv').config();\n\nconst authRoutes = require('./routes/auth');\nconst userRoutes = require('./routes/users');\nconst { errorHandler } = require('./middleware/errorHandler');\nconst { authenticateToken } = require('./middleware/auth');\n\nconst app = express();\nconst PORT = process.env.PORT || 3000;\n\n// Security middleware\napp.use(helmet());\napp.use(cors());\n\n// Rate limiting\nconst limiter = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  max: 100 // limit each IP to 100 requests per windowMs\n});\napp.use(limiter);\n\n// Body parsing middleware\napp.use(express.json({ limit: '10mb' }));\napp.use(express.urlencoded({ extended: true }));\n\n// Database connection\nmongoose.connect(process.env.MONGODB_URI || 'mongodb://localhost:27017/authservice', {\n  useNewUrlParser: true,\n  useUnifiedTopology: true,\n});\n\nmongoose.connection.on('connected', () => {\n  console.log('Connected to MongoDB');\n});\n\nmongoose.connection.on('error', (err) => {\n  console.error('MongoDB connection error:', err);\n});\n\n// Health check endpoint\napp.get('/health', (req, res) => {\n  res.json({\n    status: 'healthy',\n    service: 'auth-service',\n    version: process.env.npm_package_version || '1.0.0',\n    timestamp: new Date().toISOString(),\n    uptime: process.uptime()\n  });\n});\n\n// Routes\napp.use('/api/auth', authRoutes);\napp.use('/api/users', authenticateToken, userRoutes);\n\n// 404 handler\napp.use('*', (req, res) => {\n  res.status(404).json({ error: 'Route not found' });\n});\n\n// Error handling middleware\napp.use(errorHandler);\n\n// Start server\nif (process.env.NODE_ENV !== 'test') {\n  app.listen(PORT, () => {\n    console.log(`Auth Service running on port ${PORT}`);\n  });\n}\n\nmodule.exports = app;",
      "src/models/User.js": "const mongoose = require('mongoose');\nconst bcrypt = require('bcryptjs');\n\nconst userSchema = new mongoose.Schema({\n  username: {\n    type: String,\n    required: true,\n    unique: true,\n    trim: true,\n    minlength: 3,\n    maxlength: 30\n  },\n  email: {\n    type: String,\n    required: true,\n    unique: true,\n    trim: true,\n    lowercase: true,\n    match: [/^\\w+([.-]?\\w+)*@\\w+([.-]?\\w+)*(\\.\\w{2,3})+$/, 'Please enter a valid email']\n  },\n  password: {\n    type: String,\n    required: true,\n    minlength: 6\n  },\n  role: {\n    type: String,\n    enum: ['user', 'admin'],\n    default: 'user'\n  },\n  isActive: {\n    type: Boolean,\n    default: true\n  },\n  lastLogin: {\n    type: Date\n  },\n  refreshTokens: [{\n    token: String,\n    createdAt: {\n      type: Date,\n      default: Date.now,\n      expires: 604800 // 7 days\n    }\n  }]\n}, {\n  timestamps: true\n});\n\n// Hash password before saving\nuserSchema.pre('save', async function(next) {\n  if (!this.isModified('password')) return next();\n  \n  try {\n    const salt = await bcrypt.genSalt(12);\n    this.password = await bcrypt.hash(this.password, salt);\n    next();\n  } catch (error) {\n    next(error);\n  }\n});\n\n// Compare password method\nuserSchema.methods.comparePassword = async function(candidatePassword) {\n  return bcrypt.compare(candidatePassword, this.password);\n};\n\n// Remove password from JSON output\nuserSchema.methods.toJSON = function() {\n  const userObject = this.toObject();\n  delete userObject.password;\n  delete userObject.refreshTokens;\n  return userObject;\n};\n\nmodule.exports = mongoose.model('User', userSchema);",
      "tests/auth.test.js": "const request = require('supertest');\nconst mongoose = require('mongoose');\nconst { MongoMemoryServer } = require('mongodb-memory-server');\nconst app = require('../src/index');\nconst User = require('../src/models/User');\n\nlet mongoServer;\n\nbeforeAll(async () => {\n  mongoServer = await MongoMemoryServer.create();\n  const mongoUri = mongoServer.getUri();\n  await mongoose.connect(mongoUri);\n});\n\nafterAll(async () => {\n  await mongoose.disconnect();\n  await mongoServer.stop();\n});\n\nbeforeEach(async () => {\n  await User.deleteMany({});\n});\n\ndescribe('Auth Endpoints', () => {\n  describe('POST /api/auth/register', () => {\n    it('should register a new user', async () => {\n      const userData = {\n        username: 'testuser',\n        email: 'test@example.com',\n        password: 'password123'\n      };\n\n      const response = await request(app)\n        .post('/api/auth/register')\n        .send(userData)\n        .expect(201);\n\n      expect(response.body.message).toBe('User registered successfully');\n      expect(response.body.user.username).toBe(userData.username);\n      expect(response.body.user.email).toBe(userData.email);\n      expect(response.body.accessToken).toBeDefined();\n      expect(response.body.refreshToken).toBeDefined();\n    });\n\n    it('should not register user with existing email', async () => {\n      const userData = {\n        username: 'testuser',\n        email: 'test@example.com',\n        password: 'password123'\n      };\n\n      // Register first user\n      await request(app)\n        .post('/api/auth/register')\n        .send(userData);\n\n      // Try to register with same email\n      const response = await request(app)\n        .post('/api/auth/register')\n        .send({\n          username: 'differentuser',\n          email: 'test@example.com',\n          password: 'password123'\n        })\n        .expect(409);\n\n      expect(response.body.error).toBe('User already exists');\n    });\n\n    it('should validate required fields', async () => {\n      const response = await request(app)\n        .post('/api/auth/register')\n        .send({\n          username: 'testuser'\n          // missing email and password\n        })\n        .expect(400);\n\n      expect(response.body.error).toContain('required');\n    });\n  });\n\n  describe('POST /api/auth/login', () => {\n    beforeEach(async () => {\n      // Create a test user\n      const user = new User({\n        username: 'testuser',\n        email: 'test@example.com',\n        password: 'password123'\n      });\n      await user.save();\n    });\n\n    it('should login with valid credentials', async () => {\n      const response = await request(app)\n        .post('/api/auth/login')\n        .send({\n          email: 'test@example.com',\n          password: 'password123'\n        })\n        .expect(200);\n\n      expect(response.body.message).toBe('Login successful');\n      expect(response.body.user.email).toBe('test@example.com');\n      expect(response.body.accessToken).toBeDefined();\n      expect(response.body.refreshToken).toBeDefined();\n    });\n\n    it('should not login with invalid password', async () => {\n      const response = await request(app)\n        .post('/api/auth/login')\n        .send({\n          email: 'test@example.com',\n          password: 'wrongpassword'\n        })\n        .expect(401);\n\n      expect(response.body.error).toBe('Invalid credentials');\n    });\n\n    it('should not login with non-existent email', async () => {\n      const response = await request(app)\n        .post('/api/auth/login')\n        .send({\n          email: 'nonexistent@example.com',\n          password: 'password123'\n        })\n        .expect(401);\n\n      expect(response.body.error).toBe('Invalid credentials');\n    });\n  });\n});\n\ndescribe('Health Check', () => {\n  it('should return health status', async () => {\n    const response = await request(app)\n      .get('/health')\n      .expect(200);\n\n    expect(response.body.status).toBe('healthy');\n    expect(response.body.service).toBe('auth-service');\n    expect(response.body.timestamp).toBeDefined();\n  });\n});",
      "Dockerfile": "FROM node:18-alpine\n\nWORKDIR /app\n\n# Copy package files\nCOPY package*.json ./\n\n# Install dependencies\nRUN npm ci --only=production\n\n# Copy source code\nCOPY src/ ./src/\n\n# Create non-root user\nRUN addgroup -g 1001 -S nodejs\nRUN adduser -S nodeuser -u 1001\n\n# Change ownership of app directory\nRUN chown -R nodeuser:nodejs /app\nUSER nodeuser\n\n# Expose port\nEXPOSE 3000\n\n# Health check\nHEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \\\n  CMD node -e \"require('http').get('http://localhost:3000/health', (res) => { process.exit(res.statusCode === 200 ? 0 : 1) })\"\n\n# Start the application\nCMD [\"node\", \"src/index.js\"]",
      ".env.example": "# JWT Secret Keys (Generate strong secrets in production)\nJWT_SECRET=your-super-secret-jwt-key-change-this-in-production\nJWT_REFRESH_SECRET=your-super-secret-refresh-key-change-this-in-production\n\n# Database\nMONGODB_URI=mongodb://localhost:27017/authservice\n\n# Server Configuration\nPORT=3000\nNODE_ENV=development\n\n# CORS Settings\nCORS_ORIGIN=http://localhost:3000"
    },
    "expected_readme": "# Express Authentication Service\n\nA robust JWT-based authentication microservice built with Express.js, MongoDB, and industry-standard security practices.\n\n## Features\n\n- **JWT Authentication**: Access and refresh token implementation\n- **Password Security**: Bcrypt hashing with salt rounds\n- **MongoDB Integration**: Mongoose ODM with schema validation\n- **Security Middleware**: Helmet, CORS, and rate limiting\n- **Input Validation**: Joi schema validation\n- **Comprehensive Testing**: Jest and Supertest integration\n- **Docker Support**: Multi-stage builds with security best practices\n- **Health Monitoring**: Built-in health check endpoints\n\n## Quick Start\n\n### Prerequisites\n\n- Node.js 16.0.0 or higher\n- MongoDB (local or cloud instance)\n- npm or yarn package manager\n\n### Local Development\n\n1. **Clone and install dependencies:**\n```bash\ngit clone <repository-url>\ncd express-auth-service\nnpm install\n```\n\n2. **Environment setup:**\n```bash\ncp .env.example .env\n# Edit .env with your configuration\n```\n\n3. **Start development server:**\n```bash\nnpm run dev\n```\n\nThe service will be available at `http://localhost:3000`\n\n### Docker Deployment\n\n```bash\n# Build the image\ndocker build -t auth-service .\n\n# Run the container\ndocker run -p 3000:3000 --env-file .env auth-service\n```\n\n## API Documentation\n\n### Authentication Endpoints\n\n#### Register User\n```http\nPOST /api/auth/register\nContent-Type: application/json\n\n{\n  \"username\": \"johndoe\",\n  \"email\": \"john@example.com\",\n  \"password\": \"securepassword123\"\n}\n```\n\n**Response:**\n```json\n{\n  \"message\": \"User registered successfully\",\n  \"user\": {\n    \"_id\": \"64f5a1b2c3d4e5f6a7b8c9d0\",\n    \"username\": \"johndoe\",\n    \"email\": \"john@example.com\",\n    \"role\": \"user\",\n    \"isActive\": true,\n    \"createdAt\": \"2023-09-04T10:30:00.000Z\",\n    \"updatedAt\": \"2023-09-04T10:30:00.000Z\"\n  },\n  \"accessToken\": \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...\",\n  \"refreshToken\": \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...\"\n}\n```\n\n#### Login\n```http\nPOST /api/auth/login\nContent-Type: application/json\n\n{\n  \"email\": \"john@example.com\",\n  \"password\": \"securepassword123\"\n}\n```\n\n#### Refresh Token\n```http\nPOST /api/auth/refresh\nContent-Type: application/json\n\n{\n  \"refreshToken\": \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...\"\n}\n```\n\n#### Logout\n```http\nPOST /api/auth/logout\nContent-Type: application/json\n\n{\n  \"refreshToken\": \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...\"\n}\n```\n\n### Protected Routes\n\nAll user routes require a valid JWT token in the Authorization header:\n\n```http\nAuthorization: Bearer <access_token>\n```\n\n### Health Check\n```http\nGET /health\n```\n\nReturns service status, version, and uptime information.\n\n## Environment Variables\n\n| Variable | Description | Default | Required |\n|----------|-------------|---------|----------|\n| `JWT_SECRET` | Secret for access tokens | - | ✅ |\n| `JWT_REFRESH_SECRET` | Secret for refresh tokens | - | ✅ |\n| `MONGODB_URI` | MongoDB connection string | `mongodb://localhost:27017/authservice` | ✅ |\n| `PORT` | Server port | `3000` | ❌ |\n| `NODE_ENV` | Environment mode | `development` | ❌ |\n| `CORS_ORIGIN` | Allowed CORS origins | `http://localhost:3000` | ❌ |\n\n## Security Features\n\n- **Password Hashing**: Bcrypt with 12 salt rounds\n- **JWT Tokens**: Separate access (15min) and refresh (7 days) tokens\n- **Rate Limiting**: 100 requests per 15 minutes per IP\n- **Input Validation**: Joi schema validation on all endpoints\n- **Security Headers**: Helmet.js for security headers\n- **CORS Protection**: Configurable cross-origin resource sharing\n\n## Database Schema\n\n### User Model\n```javascript\n{\n  username: String (required, unique, 3-30 chars)\n  email: String (required, unique, valid email)\n  password: String (required, min 6 chars, hashed)\n  role: String (enum: ['user', 'admin'], default: 'user')\n  isActive: Boolean (default: true)\n  lastLogin: Date\n  refreshTokens: [{ token: String, createdAt: Date }]\n  createdAt: Date\n  updatedAt: Date\n}\n```\n\n## Testing\n\n### Run Test Suite\n```bash\n# Run all tests\nnpm test\n\n# Run tests in watch mode\nnpm run test:watch\n\n# Run tests with coverage\nnpm run test:coverage\n```\n\n### Test Coverage\nThe test suite includes:\n- Authentication flow testing\n- Input validation testing\n- Error handling testing\n- Security testing\n- Integration testing with in-memory MongoDB\n\n## Development\n\n### Scripts\n- `npm start` - Start production server\n- `npm run dev` - Start development server with nodemon\n- `npm test` - Run test suite\n- `npm run lint` - Run ESLint\n- `npm run lint:fix` - Fix ESLint issues\n\n### Code Quality\n- ESLint for code linting\n- Jest for testing\n- Prettier for code formatting (recommended)\n\n## Production Deployment\n\n### Docker\nThe service includes a multi-stage Dockerfile optimized for production:\n- Alpine Linux base for smaller image size\n- Non-root user for security\n- Health checks included\n- Production dependencies only\n\n### Kubernetes\nExample deployment configuration:\n```yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: auth-service\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: auth-service\n  template:\n    metadata:\n      labels:\n        app: auth-service\n    spec:\n      containers:\n      - name: auth-service\n        image: auth-service:latest\n        ports:\n        - containerPort: 3000\n        env:\n        - name: MONGODB_URI\n          valueFrom:\n            secretKeyRef:\n              name: auth-secrets\n              key: mongodb-uri\n        - name: JWT_SECRET\n          valueFrom:\n            secretKeyRef:\n              name: auth-secrets\n              key: jwt-secret\n```\n\n## Monitoring and Logging\n\n- Health check endpoint for load balancer monitoring\n- Structured error responses\n- Request/response logging (add winston for production)\n- Database connection monitoring\n\n## Contributing\n\n1. Fork the repository\n2. Create a feature branch\n3. Write tests for new features\n4. Ensure all tests pass\n5. Submit a pull request\n\n## License\n\nMIT License - see LICENSE file for details\n\n## Support\n\nFor questions or issues, please create an issue in the repository or contact the development team."
  }
]
